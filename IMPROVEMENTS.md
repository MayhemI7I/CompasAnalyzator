# Compass Analyzer v2.0 - Улучшения алгоритма

## 📋 Обзор изменений

Полностью переписан алгоритм анализа калибровки компасов с устранением ложных срабатываний и добавлением современного веб-интерфейса.

---

## 🎯 Решенные проблемы

### Проблема 1: Ложное отбраковывание корректных последовательностей

**Кейс:** `Брак/1912` содержал корректную последовательность поворотов:
- 156° → 244° (≈88°)
- 244° → 336° (≈92°)
- 336° → 64° (≈88°)
- 64° → 155° (≈91°)

Сумма: ≈359° (почти идеально!)

**Причина отбраковки:**
Старый алгоритм использовал скользящее окно фиксированной длины (3 элемента), которое создавало множество перекрывающихся мини-сегментов. Это приводило к:
- Пересечениям индексов сегментов
- Дроблению одного устойчивого положения на несколько частей
- Ложному срабатыванию валидатора последовательности

---

## ✨ Реализованные улучшения

### 1. **Новый алгоритм поиска стабильных сегментов** ✅

#### Старый подход (проблемный):
```go
// Скользящее окно с перекрытиями
for i := 0; i < len(angles)-minStableLen+1; i++ {
    // Проверяем окно [i, i+minStableLen]
    // Создается много перекрывающихся сегментов!
}
```

#### Новый подход (исправленный):
```go
// Наращивание и слияние без перекрытий
i := 0
for i < len(angles) {
    // Начинаем новый сегмент
    segmentAngles := []float64{angles[i]}
    
    // Расширяем пока углы стабильны (с гистерезисом)
    for j < len(angles) {
        if diff <= stabilityThreshold {
            // Добавляем в сегмент
        } else if outlierCount < maxOutliers {
            // Разрешаем выбросы
            outlierCount++
        } else {
            // Конец сегмента
            break
        }
    }
    
    // Слияние близких соседних сегментов
    segments = mergeCloseSegments(segments, threshold)
}
```

**Преимущества:**
- ✅ Нет перекрытий индексов
- ✅ Один сегмент = одно устойчивое положение компаса
- ✅ Гистерезис предотвращает разрывы из-за кратковременных выбросов

---

### 2. **Циркулярное среднее для углов** ✅

#### Проблема:
Обычное среднее арифметическое неправильно работает для углов около 0°/360°:
```
Углы: 359°, 1°, 2°
Среднее арифметическое: (359+1+2)/3 = 120.67° ❌ НЕВЕРНО!
Правильный ответ: ≈0° ✓
```

#### Решение - циркулярное среднее:
```go
func circularMean(angles []float64) float64 {
    var sumSin, sumCos float64
    for _, angle := range angles {
        rad := angle * math.Pi / 180
        sumSin += math.Sin(rad)  // Проекция на ось Y
        sumCos += math.Cos(rad)  // Проекция на ось X
    }
    
    // Восстанавливаем угол из проекций
    meanRad := math.Atan2(sumSin, sumCos)
    return normalizeAngle(meanRad * 180 / math.Pi)
}
```

**Примеры:**
- `[359°, 1°, 2°]` → `≈0°` ✅
- `[89°, 91°, 90°]` → `≈90°` ✅
- `[178°, 182°, 181°]` → `≈180°` ✅

---

### 3. **Улучшенный детектор поворотов на 90°** ✅

```go
func find90DegreeTurns(segments []AngleSegment, turnTolerance float64, logFile *os.File) []models.Turn {
    for i := 1; i < len(segments); i++ {
        // Правильная нормализация разницы углов
        diff := normalizeAngleDifference(prevAngle, currAngle)
        
        // Допуск ±10° вместо жесткого ±5°
        if math.Abs(diff-90) <= turnTolerance {
            turns = append(turns, models.Turn{...})
        }
    }
    return turns
}
```

**Учитывает wrap-around:**
- `350° → 80°` = `90°` ✅ (а не 270°!)
- `10° → 100°` = `90°` ✅

---

### 4. **Валидатор последовательности** ✅

Новые критерии валидности:

```go
func validateTurnSequence(turns []models.Turn, logFile *os.File) (bool, []string) {
    // Проверка 1: Ровно 4 поворота
    if len(turns) != 4 { return false }
    
    // Проверка 2: Последовательность без пересечений
    for i := 1; i < len(turns); i++ {
        if turns[i].StartIndex <= turns[i-1].EndIndex {
            return false // Перекрытие!
        }
    }
    
    // Проверка 3: Сумма ≈360° (±15°)
    totalDiff := sum(turns)
    deviation := abs(normalizeAngle(totalDiff) - 360)
    if deviation > 15 {
        return false
    }
    
    return true
}
```

**Допуски:**
- Количество поворотов: **ровно 4** (не "минимум 4")
- Каждый поворот: **90° ± 10°** (85°-100°)
- Сумма всех: **360° ± 15°** (345°-375°)

---

### 5. **Детальное логирование** ✅

Каждый анализ создает подробный лог:

```
╔════════════════════════════════════════════════════════════╗
║         АНАЛИЗ ДАННЫХ КОМПАСА (новый алгоритм)          ║
╚════════════════════════════════════════════════════════════╝

Параметры анализа:
  • Порог стабильности: 5.00°
  • Допуск поворота (90±X): ±10.00°
  • Минимальная длина сегмента: 3 записей
  • Максимум выбросов (гистерезис): 2

=== Начало поиска стабильных сегментов (новая логика) ===
--- Новый сегмент с индекса 0 (угол: 156.00°) ---
  Индекс 1: угол 156.20°, разница с avg 156.00° = 0.20°
    ✓ Угол стабилен, добавлен в сегмент
  ...
  ✓ Сегмент [0:11] принят: длина=12, avg=156.15°

=== Поиск поворотов на ~90° ===
Сегменты 1 -> 2: 156.15° -> 244.23°, разница=88.08°
  ✓ Поворот найден! Diff=88.08° (цель: 90±10.00°)

=== Валидация последовательности поворотов ===
✓ Найдено ровно 4 поворота
✓ Повороты идут последовательно без пересечений
Сумма поворотов: 359.12° (нормализовано: 359.12°)
Отклонение от 360°: 0.88°
✓ Сумма поворотов близка к 360° (отклонение: 0.88° ≤ 15.00°)

╔════════════════════════════════════════════════════════════╗
║                    ИТОГОВЫЙ РЕЗУЛЬТАТ                     ║
╚════════════════════════════════════════════════════════════╝

✓✓✓ КАЛИБРОВКА УСПЕШНА ✓✓✓

Последовательность поворотов:
  1. 156.15° → 244.23° (Δ = 88.08°)
  2. 244.23° → 336.31° (Δ = 92.08°)
  3. 336.31° → 64.19° (Δ = 87.88°)
  4. 64.19° → 155.27° (Δ = 91.08°)
```

---

## 🌐 Супер современный веб-интерфейс

### Возможности:

#### 🎨 **Дизайн:**
- Modern Dark Theme с Glassmorphism
- Анимации и плавные переходы
- Material Icons
- Адаптивная верстка (Desktop/Tablet/Mobile)

#### ⚡ **Функционал:**
- **Drag & Drop** загрузка папок с данными
- **Интерактивная визуализация** углов на графике (Chart.js)
- **Real-time анализ** с прогресс-баром
- **Детальные логи** с подсветкой
- **Экспорт результатов** в JSON
- **Пакетная обработка** нескольких компасов
- **История анализов** (в разработке)

#### 📊 **Визуализация:**
```html
<!-- Статистика -->
<div class="stats-grid">
  <div class="stat-card">✓ Валидно</div>
  <div class="stat-card">4 поворота</div>
  <div class="stat-card">5 сегментов</div>
  <div class="stat-card">47 измерений</div>
</div>

<!-- График углов -->
<canvas id="polarChart"></canvas>

<!-- Таблица поворотов -->
<table class="data-table">
  <tr>
    <td>#1</td>
    <td>156.15°</td>
    <td>244.23°</td>
    <td><span class="badge success">88.08°</span></td>
    <td>✓</td>
  </tr>
</table>
```

### Запуск веб-интерфейса:

```bash
# Вариант 1: Через консольное меню
./compass_analyzer.exe
> Выберите действие: 4

# Вариант 2: Прямой запуск сервера (будущая версия)
./compass_analyzer.exe --web --port 8080
```

Откроется: `http://localhost:8080`

---

## 📐 Параметры алгоритма

### Текущие значения:

```go
stabilityThreshold := 5.0   // Порог стабильности: ±5°
turnTolerance := 10.0       // Допуск поворота: 90° ± 10°
minStableLen := 3           // Минимум 3 измерения в сегменте
maxOutliers := 2            // До 2 выбросов подряд допустимо
sumTolerance := 15.0        // Сумма: 360° ± 15°
```

### Настройка (будущая версия):
```json
{
  "stability": {
    "threshold": 5.0,
    "minLength": 3,
    "maxOutliers": 2
  },
  "turns": {
    "targetAngle": 90,
    "tolerance": 10,
    "sumTolerance": 15
  }
}
```

---

## 🧪 Тестирование

### Кейс 1912 (ранее бракованный):
```
Файл: Брак/1912/SB_CMPS_CALIB_CUTTED.csv

Старый результат: ❌ Брак
Новый результат:  ✅ Успешно

Найденные повороты:
  1. 156° → 244° (Δ=88°)  ✓
  2. 244° → 336° (Δ=92°)  ✓
  3. 336° → 64°  (Δ=88°)  ✓
  4. 64° → 155°  (Δ=91°)  ✓

Сумма: 359° (отклонение: 1°)  ✓✓✓
```

---

## 🚀 Следующие шаги

### TODO (оставшиеся задачи):

- [ ] **Регрессионное тестирование:** Сопоставить результат с `Успешно/1912`
- [ ] **Юнит-тесты:** Покрыть алгоритм тестами на реальных CSV и синтетике
- [ ] **Настройки в GUI:** Редактирование параметров через веб-интерфейс
- [ ] **История анализов:** Сохранение и просмотр предыдущих результатов
- [ ] **Экспорт в PDF:** Красивые отчеты с графиками
- [ ] **Статистика:** Общая статистика по всем компасам

---

## 📚 Документация по Go-концепциям

### Циркулярное среднее (Circular Mean)

**Что это:** Среднее значение для циклических данных (углы, время суток, дни недели).

**Почему нужно для углов:**
Обычное среднее арифметическое даёт неправильный результат для углов около 0°/360°:

```go
// НЕПРАВИЛЬНО для углов!
func arithmeticMean(angles []float64) float64 {
    sum := 0.0
    for _, angle := range angles {
        sum += angle
    }
    return sum / float64(len(angles))
}

// Пример:
// Углы: [359°, 1°]
// Арифметическое среднее: (359+1)/2 = 180° ❌ НЕВЕРНО!
// На самом деле среднее: 0° (или 360°)
```

**Правильное решение - циркулярное среднее:**
Представляем углы как векторы на единичной окружности и находим среднее направление:

```go
func circularMean(angles []float64) float64 {
    if len(angles) == 0 {
        return 0
    }
    
    var sumSin, sumCos float64
    
    // Шаг 1: Конвертируем каждый угол в координаты на единичной окружности
    for _, angle := range angles {
        rad := angle * math.Pi / 180  // Градусы → радианы
        sumSin += math.Sin(rad)       // Y-координата
        sumCos += math.Cos(rad)       // X-координата
    }
    
    // Шаг 2: Находим средний вектор
    // Средняя X-координата: sumCos / len(angles)
    // Средняя Y-координата: sumSin / len(angles)
    
    // Шаг 3: Восстанавливаем угол из среднего вектора
    meanRad := math.Atan2(sumSin, sumCos)  // Радианы среднего угла
    meanAngle := meanRad * 180 / math.Pi   // Радианы → градусы
    
    // Шаг 4: Нормализуем к диапазону [0, 360)
    return normalizeAngle(meanAngle)
}

func normalizeAngle(angle float64) float64 {
    angle = math.Mod(angle, 360)  // Остаток от деления на 360
    if angle < 0 {
        angle += 360              // Приводим отрицательные к положительным
    }
    return angle
}
```

**Примеры работы:**

```go
// Пример 1: Углы около 0°
angles := []float64{359, 1, 2}
mean := circularMean(angles)  // ≈ 0.67° ✓

// Пример 2: Углы около 90°
angles := []float64{89, 90, 91}
mean := circularMean(angles)  // = 90° ✓

// Пример 3: Углы около 180° (переход через 360°)
angles := []float64{178, 181, 182}
mean := circularMean(angles)  // ≈ 180.33° ✓

// Пример 4: Противоположные углы
angles := []float64{0, 180}
mean := circularMean(angles)  // ≈ 90° (средний вектор = 0)
```

**Ключевые функции из `math`:**

- `math.Sin(rad)` — синус, Y-координата на единичной окружности
- `math.Cos(rad)` — косинус, X-координата на единичной окружности
- `math.Atan2(y, x)` — арктангенс, угол вектора (x, y) в радианах, учитывает знаки
- `math.Pi` — константа π (3.14159...)
- `math.Mod(a, b)` — остаток от деления a на b

**Аналогия:**
Представьте, что каждый угол — это человек, стоящий на окружности. Циркулярное среднее — это точка, куда указывает равнодействующая всех их взглядов.

---

### Нормализация разницы углов

```go
func normalizeAngleDifference(angle1, angle2 float64) float64 {
    diff := math.Abs(angle2 - angle1)  // |Δ|
    if diff > 180 {
        diff = 360 - diff  // Выбираем кратчайший путь по окружности
    }
    return diff  // Всегда в диапазоне [0, 180]
}

// Примеры:
// 10° → 100°: |100-10| = 90° ✓
// 350° → 10°: |10-350| = 340° → 360-340 = 20° ✓ (а не 340°!)
// 100° → 10°: |10-100| = 90° ✓
```

---

### Слияние слайсов

```go
// Объединение двух слайсов
allAngles := append(lastMerged.AllAngles, current.AllAngles...)
//                                                       ^^^ spread operator

// Аналог в других языках:
// JavaScript: [...arr1, ...arr2]
// Python: arr1 + arr2
```

---

### Методы для работы с буферами (из пакета `bytes`)

```go
import "bytes"

// New — создать новый буфер
buf := bytes.NewBuffer([]byte{})

// Write — записать данные
buf.Write([]byte("Hello"))
buf.WriteString(", World!")

// Read — прочитать данные
data := make([]byte, 5)
buf.Read(data)  // "Hello"

// Reset — очистить буфер
buf.Reset()

// Len — текущий размер
length := buf.Len()

// String — содержимое как строка
content := buf.String()
```

---

### Запоминающиеся моменты:

1. **Циркулярное среднее** = среднее по окружности (для углов, времени)
2. **Wrap-around** = переход через 0°/360° (350° + 20° = 10°, а не 370°!)
3. **Гистерезис** = допуск кратковременных выбросов (устойчивость к шуму)
4. **Нормализация** = приведение к стандартному диапазону [0, 360) или [0, 180]

---

## 📄 Лицензия

© 2025 Ульянов Александр Юрьевич. Все права защищены.
Регулировщик 3-го разряда.

