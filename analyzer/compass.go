package analyzer

// AnalyzeCompassData анализирует данные компаса и ищет четыре последовательных поворота
// примерно на 90 градусов, за которыми следует короткий стабильный участок.
// Подробная информация о процессе анализа записывается в файл лога.
//
// Логика анализа:
//
//  1. Функция итерируется по всем записям данных компаса.
//
//  2. Для каждой записи вычисляется разница угла по сравнению с углом последней
//     найденной стабильной точки или начальным углом (для первой записи).
//
//  3. Если разница угла находится в диапазоне 80-100 градусов (с учетом
//     "допуска поворота" turnTolerance), это считается потенциальным поворотом на 90 градусов.
//     Нормализация угла (приведение к диапазону 0-180 для разницы) выполняется
//     с помощью `math.Abs` и коррекции, если разница превышает 180 градусов.
//
//     Пример проверки поворота:
//     ```go
//     angleDiff := math.Abs(data[i].Angle - lastAngle)
//     if angleDiff > 180 {
//     angleDiff = 360 - angleDiff
//     }
//     if angleDiff >= 90-turnTolerance && angleDiff <= 90+turnTolerance {
//     // Потенциальный поворот найден
//     }
//     ```
//
//  4. После обнаружения потенциального поворота, функция проверяет следующие
//     1-4 записи данных на наличие стабильного участка. Стабильным считается угол,
//     который отличается от угла в точке потенциального поворота не более чем
//     на "допуск стабильности" (stableTolerance = 5 градусов).
//
// 5. Учитывается наличие промежуточных "нестабильных" записей в пределах этих 4 точек:
//
//   - Допускается *максимум одна* запись, которая не соответствует критерию
//     стабильности (разница угла больше stableTolerance).
//
//   - Если найдено две или более таких промежуточных записей до обнаружения
//     стабильного участка (1-3 точки), поиск этого стабильного участка сбрасывается,
//     и процесс поиска поворота возобновляется с точки потенциального поворота.
//
//     6. Если в течение следующих 1-3 записей после потенциального поворота найден
//     стабильный участок (углы в пределах stableTolerance), то:
//
//   - Считается, что поворот успешно идентифицирован.
//
//   - Счетчик найденных поворотов увеличивается.
//
//   - Угол последней стабильной точки в этом сегменте становится новой точкой отсчета
//     (lastAngle) для поиска следующего поворота.
//
//   - Итерация по данным продолжается с последней записи найденного стабильного участка.
//
//     Пример проверки стабильности после поворота:
//     ```go
//     stableAngleAfterTurn := data[i].Angle // Угол в точке потенциального поворота
//     stableCount := 0
//     intermediateCount := 0
//     for j := i + 1; j < len(data) && j <= i + 4; j++ {
//     currentStableDiff := math.Abs(data[j].Angle - stableAngleAfterTurn)
//     if currentStableDiff <= stableTolerance {
//     stableCount++
//     if stableCount >= 1 && stableCount <= 3 {
//     // Стабильный участок найден
//     lastAngle = data[j].Angle // Обновляем точку отсчета
//     // Увеличиваем счетчик поворотов, сохраняем разницу угла и переходим к следующей итерации внешнего цикла с j
//     break // Выход из внутреннего цикла после нахождения стабильного участка
//     }
//     } else {
//     intermediateCount++
//     if intermediateCount > 1 {
//     // Слишком много промежуточных точек, сброс поиска стабильности
//     break
//     }
//     }
//     }
//     // Проверка stableFound после внутреннего цикла для определения, был ли найден стабильный участок
//     ```
//
//     7. Если после потенциального поворота не удается найти стабильный участок
//     в течение 4 записей (с учетом правила об одной промежуточной записи),
//     счетчик стабильности сбрасывается, и поиск поворота продолжается с точки
//     потенциального поворота (lastAngle остается углом этой точки).
//
//     8. Если текущая запись не является потенциальным поворотом (разница угла
//     не в диапазоне 80-100), угол текущей записи становится новой точкой отсчета (lastAngle)
//     для следующей итерации.
//
//     9. После итерации по всем данным проверяется общее количество найденных
//     поворотов. Если найдено ровно четыре, анализ считается успешным
//     (без учета временных условий, которые пока не реализованы в новой логике).
//
// Параметры:
//   - data: массив данных компаса для анализа (считается, что data[0] - это начальный угол)
//   - logFilePath: путь к файлу, куда будет записываться подробный лог анализа
//
// Возвращает:
//   - models.CompassResult: результаты анализа с информацией о найденных поворотах
//     (Angles) и ошибках (Errors), а также общий статус валидности (IsValid).
//
// TODO: Добавить проверку временных интервалов между найденными поворотами и общего времени анализа на основе меток времени в data.
//
// Пример:
//
//	result := AnalyzeCompassData(compassData, "path/to/log.txt")
//	if result.IsValid {
//	    fmt.Println("Анализ успешен. Найденные изменения угла:", result.Angles)
//	} else {
//	    fmt.Println("Анализ неуспешен. Ошибки:", result.Errors)
//	}
